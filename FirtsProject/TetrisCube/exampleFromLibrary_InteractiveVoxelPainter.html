<html lang="en">
	<head>
		<title>three.js webgl - interactive - voxel painter</title>
		<meta charset="utf-8">
		<style> * {margin: 0;padding: 0;}</style>
		<script type="importmap">
			{
				"imports": {
					"three": "https://unpkg.com/three@0.138.0/build/three.module.js",
					"OrbitControls": "https://unpkg.com/three@0.138.0/examples/jsm/controls/OrbitControls.js"
				}
			}
		</script>
		<script type="module">

			import * as THREE from 'three';
			import { OrbitControls } from 'https://unpkg.com/three/examples/jsm/controls/OrbitControls.js';

			let camera, scene, renderer, controls;
			let plane;
			let pointer, raycaster, isShiftDown = false;

			let rollOverMesh, rollOverMaterial;
			let cubeGeo, cubeMaterial;
			let sizeCube = 3;			
			let currentCubeNumber = 0;
			let maxCubeNumber = sizeCube * sizeCube * sizeCube;
			let currentElement = 1;

			const objects = [];
			const objectsOfElements = {};

			function init() {
			
				if(objectsOfElements[currentElement] == undefined){
					objectsOfElements[currentElement] = objects;}
				else{
					objects.push( objectsOfElements[currentElement]);
				}
				camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 1000 );
				camera.position.set( 5, 8, 9 );
				camera.lookAt( sizeCube / 2, sizeCube / 2, sizeCube / 2 );

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0xf0f0f0 );

				// roll-over helpers

				const rollOverGeo = new THREE.BoxGeometry( 1, 1, 1 );
				const point3D = new THREE.Vector3( 0, 0, 0 ).addScalar(0.5);

				rollOverMaterial = new THREE.MeshBasicMaterial( { color: 0xff0000, opacity: 0.5, transparent: true } );
				rollOverMesh = new THREE.Mesh( rollOverGeo, rollOverMaterial );
				rollOverMesh.position.copy(point3D);
				scene.add( rollOverMesh );

				// cubes

				cubeGeo = new THREE.BoxGeometry( 1, 1, 1 );
				//cubeMaterial = new THREE.MeshPhongMaterial({color: '#906090'});;

				// grid

				const gridHelperZ = new THREE.GridHelper( 5, 5 );
				gridHelperZ.translateX(2.5);
				gridHelperZ.translateZ(2.5);
				scene.add( gridHelperZ );
				const gridHelperY = new THREE.GridHelper( 5, 5 );
				gridHelperY.rotation.x=Math.PI/2;
				gridHelperY.translateX(2.5);
				gridHelperY.translateZ(-2.5);
				scene.add( gridHelperY );
				const gridHelperX = new THREE.GridHelper( 5, 5 );
				gridHelperX.rotation.z=Math.PI/2;
				gridHelperX.translateX(2.5);
				gridHelperX.translateZ(2.5);
				scene.add( gridHelperX );

				raycaster = new THREE.Raycaster();
				pointer = new THREE.Vector2();

				const geometry = new THREE.PlaneGeometry( sizeCube,sizeCube );
				geometry.rotateX( - Math.PI / 2 );
				geometry.translate(sizeCube/2,0,sizeCube/2);
				
				if(objectsOfElements[currentElement] !== undefined)
				{
					console.log(objectsOfElements[currentElement]);
					Object.assign(objects, objectsOfElements[currentElement]);
					objects.forEach(element => scene.add(element));
				}
				plane = new THREE.Mesh( geometry, new THREE.MeshBasicMaterial( { visible: true } ) );
				AddObject(plane);

				// lights

				const ambientLight = new THREE.AmbientLight( 0x606060 );
				scene.add( ambientLight );

				const directionalLight = new THREE.DirectionalLight( 0xffffff );
				directionalLight.position.set( 1, 0.75, 0.5 ).normalize();
				scene.add( directionalLight );

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				
				document.body.appendChild( renderer.domElement );
				
				//OrbitControls
				
				controls = new OrbitControls(camera, renderer.domElement);
				controls.target.set(0, 0, 0);
				controls.enablePan = false;
				controls.enableDamping = true;

				window.requestAnimationFrame(render);
			}

			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
				//render();
			}
			function onPointerMove( event ) {
				pointer.set( ( event.clientX / window.innerWidth ) * 2 - 1, - ( event.clientY / window.innerHeight ) * 2 + 1 );
				raycaster.setFromCamera( pointer, camera );
				const intersects = raycaster.intersectObjects( objects, false );
				if ( intersects.length > 0 ) {
					const intersect = intersects[ 0 ];
					intersect.point.max(new THREE.Vector3( 0, 0, 0 ));
					intersect.point.min(new THREE.Vector3( sizeCube - 1, sizeCube - 1, sizeCube - 1));
					rollOverMesh.position.copy( intersect.point );//.add( intersect.face.normal );
					rollOverMesh.position.divideScalar( 1 ).floor().multiplyScalar( 1 ).addScalar( 0.5 );
					//render();
				}
			}
			function onPointerDown( event ) {
				pointer.set( ( event.clientX / window.innerWidth ) * 2 - 1, - ( event.clientY / window.innerHeight ) * 2 + 1 );
				raycaster.setFromCamera( pointer, camera );
				const intersects = raycaster.intersectObjects( objects, false );
				if ( intersects.length > 0 ) {
					const intersect = intersects[ 0 ];
					// delete cube
					if ( isShiftDown ) {
						if ( intersect.object !== plane ) {
							scene.remove( intersect.object );
							objects.splice( objects.indexOf( intersect.object ), 1 );
							currentCubeNumber--;
						}
						// create cube
					} else {
						//cubeMaterial = new THREE.MeshPhongMaterial({color: parseInt(colorNodeToHex(), 16)});
						cubeMaterial = new THREE.MeshPhongMaterial({color: getRadioColor()});
						const voxel = new THREE.Mesh( cubeGeo, cubeMaterial );
						intersect.point.max(new THREE.Vector3( 0, 0, 0 ));
						intersect.point.min(new THREE.Vector3( sizeCube - 1, sizeCube - 1, sizeCube - 1));
						voxel.position.copy( intersect.point );//.add( intersect.face.normal );
						voxel.position.divideScalar( 1 ).floor().multiplyScalar( 1 ).addScalar( 0.5 );
						voxel.name = "cube";
						AddObject(voxel);
					}
					document.getElementById('SumOfCubes').innerText = CountCubes();
					//render();
				}
			}
			function onDocumentKeyDown( event ) {
				switch ( event.keyCode ) {
					case 16: isShiftDown = true; break;
				}
			}
			function onDocumentKeyUp( event ) {
				switch ( event.keyCode ) {
					case 16: isShiftDown = false; break;
				}
			}
			function render(){
				controls.update();
				renderer.render( scene, camera );
				window.requestAnimationFrame(render);
			}
			function getRadioColor(){
				for (let radioColor of document.getElementsByClassName("RadioColor")) 
				{ 
					if(radioColor.checked == true)
					{
						return radioColor.id;
					}
				}
				return "red";
			}
			function ChangeSizeAndInitNewView(){
				sizeCube = document.getElementById('Size').value;
				maxCubeNumber = sizeCube * sizeCube * sizeCube;
				camera.lookAt( sizeCube / 2, sizeCube / 2, sizeCube / 2 );

				document.getElementById('MaxCubes').value = maxCubeNumber;
				scene = new THREE.Scene();
				objects.length = 0
				document.getElementsByTagName('canvas')[0].remove();
				init();
			}
			function ChangeElementAndInitNewView(){
				if(currentElement<parseInt(document.getElementById("CurrentElement").value))
				{
					if(CountCubes() >= maxCubeNumber)
					{
						document.getElementById("CurrentElement").value = currentElement;return;
					}
				}
				
				scene = new THREE.Scene();
				var copy=[];
				Object.assign(copy, objects);
				objectsOfElements[currentElement] = copy;
				objects.length = 0;
				currentElement = parseInt(document.getElementById("CurrentElement").value);

				document.getElementsByTagName('canvas')[0].remove();
				init();
			}
			function AddObject(obj){
				const vector = new THREE.Vector3();
				const isBelowThreshold = (currentValue) => vector.subVectors(currentValue.position, obj.position).length() != 0;
				if(objects.length ==0 && !objects.every(isBelowThreshold)){return;}
				if(CountCubes() >= maxCubeNumber){return;}
				scene.add( obj );
				objects.push( obj );
				currentCubeNumber++;
			}
			
			function CountCubes(){
				let sum = 0;
				for (var [key, value] of Object.entries(objectsOfElements)) {
					const result = value.filter(element => element.name =="cube");
					sum = sum + result.length;
				}
				return sum;
			}
			
			window.addEventListener('changeSize', ChangeSizeAndInitNewView);
			window.addEventListener('changeElement', ChangeElementAndInitNewView);
			document.addEventListener( 'pointermove', onPointerMove );
			document.addEventListener( 'contextmenu', onPointerDown );
			document.addEventListener( 'keydown', onDocumentKeyDown );
			document.addEventListener( 'keyup', onDocumentKeyUp );

			window.addEventListener( 'resize', onWindowResize );
			window.onload = init;

		</script>
		<script>
		function checkValueSize(e)
		{
			if(e.target.value < 1 )
			{
				e.target.value = 1;return;
			}
			if(parseInt(e.target.value) > parseInt(e.target.max) )
			{
				e.target.value = parseInt(e.target.max);return;
			}
			
			var event = new MouseEvent('changeSize', {'view': window,'bubbles': true,'cancelable': true });
			document.getElementById('Size').dispatchEvent(event);
		}
		function checkValueElement(e)
		{
			if(e.target.value < 1 )
			{
				e.target.value = 1;return;
			}

			
			var event = new MouseEvent('changeElement', {'view': window,'bubbles': true,'cancelable': true });
			document.getElementById('CurrentElement').dispatchEvent(event);
		}
		function uncheckRadios(e)
		{
			var save = e.target.checked;
			for (let f of document.getElementsByClassName("RadioColor")) { f.checked = false; }
			e.target.checked = save;
		}
		</script>
	
	</head>
	<body>
		<label for="fname">Size</label>
		<input type="number" id="Size" onchange=checkValueSize(event) value=3 min=1 max=5>
		<label for="fname">Red</label>
		<input class="RadioColor" type="radio" id="red" onchange=uncheckRadios(event) checked=true>
		<label for="fname">Green</label>
		<input class="RadioColor" type="radio" id="green" onchange=uncheckRadios(event)>
		<label for="fname">Yellow</label>
		<input class="RadioColor" type="radio" id="yellow" onchange=uncheckRadios(event)>
		<label for="fname">Blue</label>
		<input class="RadioColor" type="radio" id="blue" onchange=uncheckRadios(event)>
		<label for="fname">White</label>
		<input class="RadioColor" type="radio" id="white" onchange=uncheckRadios(event)>
		
		<input type="number" id="CurrentElement" onchange=checkValueElement(event) value=1 min=1 max =125>
		<label for="fname"> of </label>
		<label for="fname" id="SumOfElements">1</label>
		<label for="fname">Cube used</label>
		<label for="fname" id="SumOfCubes">0</label>
		<label for="fname"> of </label>
		<label for="fname" id="MaxCubes">27</label>
	
		<button>Save a file<button>

	</body>
</html>